package generator

// https://github.com/mailru/easyjson
import (
	"fmt"
	"io"
	"os"
	"path"
	"reflect"
	"strings"

	"github.com/guionardo/go-router/pkg/attributor"
	"github.com/guionardo/go-router/pkg/generator/parsers"
	"github.com/guionardo/go-router/pkg/tools"
	"github.com/guionardo/go/pkg/set"
	"github.com/mailru/easyjson"
)

type (
	mu interface {
		easyjson.MarshalerUnmarshaler
	}
	Generator[T mu, R mu] struct {
		tReq, tRes       reflect.Type
		err              error
		w                *GoFileBuilder
		imports          set.Set[string]   // alias:path
		sources          map[string]string // type:filename
		outputs          map[string]string // type:output_filename
		typePackageAlias map[reflect.Type]string
		moduleName       string
		projectRoot      string
		attr             attributor.Attributor
		hasValidations   bool
	}
)

const sourceRowDelimiter = "// ====================\n\n"

func New[T mu, R mu]() *Generator[T, R] {
	g := &Generator[T, R]{
		imports:          set.Set[string]{},
		sources:          make(map[string]string, 2),
		outputs:          make(map[string]string, 2),
		typePackageAlias: make(map[reflect.Type]string, 2),
		attr:             attributor.New[T](),
	}

	var err error
	g.projectRoot, err = getProjectRootFolder()
	if err != nil {
		panic(err)
	}
	g.moduleName, err = getModuleName(path.Join(g.projectRoot, "go.mod"))
	if err != nil {
		panic(err)
	}
	g.tReq = g.addType(reflect.TypeFor[T]())
	g.tRes = g.addType(reflect.TypeFor[R]())

	pathParser := parsers.NewPath[T]()
	queryParser := parsers.NewQuery[T]()
	headerParser := parsers.NewHeader[T]()
	validatorParser := parsers.NewValidators[T]()

	g.hasValidations = validatorParser.HasValidations

	g.imports.AddMultiple("net/http", tools.ToolsImport)
	g.imports.UpdateFrom(pathParser.Imports)
	g.imports.UpdateFrom(queryParser.Imports)
	g.imports.UpdateFrom(headerParser.Imports)
	g.imports.UpdateFrom(validatorParser.Imports)

	return g
}

func (g *Generator[T, R]) addType(t reflect.Type) reflect.Type {
	if t.Kind() == reflect.Pointer {
		t = t.Elem()
	}
	pkgPath := t.PkgPath()
	if len(pkgPath) == 0 {
		panic(fmt.Sprintf("Couldn't identify the package path for type %s", t.Name()))
	}

	sourceFile, err := g.findSourceFile(t)
	if err != nil {
		panic(err)
	}
	g.sources[t.Name()] = sourceFile

	outputFile, found := strings.CutSuffix(sourceFile, ".go")
	if !found {
		panic(fmt.Sprintf("Couldn't identify the sourcefile output for type %s from source %s", t.Name(), sourceFile))
	}
	g.outputs[t.Name()] = fmt.Sprintf("%s_%s_handler.go", outputFile, toSnakeCase(t.Name()))
	g.typePackageAlias[t] = path.Base(pkgPath)

	//TODO: Validar
	reader, _ := NewDocReader(sourceFile)
	reader.Print()

	return t
}

func (g *Generator[T, R]) Generate(w io.Writer) error {
	g.w = NewGoFileBuilder(w)

	g.w.write(
		g.w.wf("package %s", g.typePackageAlias[g.tReq]),
		g.w.wf("\n// AUTOMATICALLY GENERATED - DO NOT EDIT THIS FILE\n"),
		g.w.wf("// Request  Type: %s", g.tReq.String()),
		g.w.wf("// Generated File: %s", g.outputs[g.tReq.Name()]),
		g.w.wf("// Response Type: %s", g.tRes.String()),

		g.writeImports,
		g.writeParser,
		g.writeInit,
	)

	return g.err
}

func (g *Generator[T, R]) writeImports() error {
	g.w.ws("import (")
	for pkg := range g.imports.Iter() {
		g.w.ws(`"%s"`, pkg)
	}
	g.w.ws(")\n")
	return nil
}

func (g *Generator[T, R]) writeInit() error {
	g.w.write(
		g.w.wf(`
		// Hash validation for type
		func init() {
tools.ValidateHash[%s](0x%x)
	}`, g.tReq.Name(), tools.TypeHash(g.tReq)))
	return nil
}
func (g *Generator[T, R]) writeParser() error {
	g.w.write(
		g.w.wf("func (h *%s) ParseRequest(r *http.Request) error {", g.tReq.Name()),
		g.writeParserForPath(),
		g.writeParserForHeaders(),
		g.writeParseQuery(),
		g.writeValidation(),
		g.w.wf("return nil"),
		g.w.wf("}"),
	)

	return nil

}

func (g *Generator[T, R]) writeParserForPath() func() error {

	attributions := make([]string, 0)
	for field, tagValue := range getFieldsByTag(g.tReq, "path") {
		attributions = append(attributions, g.attr.Create(field, "h", `r.PathValue("%s")`, tagValue))
	}
	if len(attributions) == 0 {
		return func() error { return nil }
	}
	return g.w.wf(`
if err:=tools.GroupError("path",
%s,
); err!=nil { return err }`, strings.Join(attributions, ",\n"))
	// return g.w.wf("// path\n%s\n%s", strings.Join(attribuitions, "\n"), sourceRowDelimiter)
}

func (g *Generator[T, R]) writeParserForHeaders() func() error {
	attributions := make([]string, 0)
	for field, tagValue := range getFieldsByTag(g.tReq, "header") {
		attributions = append(attributions, g.attr.Create(field, "h", `r.Header.Get("%s")`, tagValue))
	}
	if len(attributions) == 0 {
		return func() error { return nil }
	}
	return g.w.wf(`
if err:=tools.GroupError("headers",
%s,
); err!=nil { return err }`, strings.Join(attributions, ",\n"))
	// return g.w.wf("// headers\n\n%s\n%s", strings.Join(attributions, "\n"), sourceRowDelimiter)
}

func (g *Generator[T, R]) writeParseQuery() func() error {
	attributions := make([]string, 0)
	for field, tagValue := range getFieldsByTag(g.tReq, "query") {
		attributions = append(attributions, g.attr.Create(field, "h", `r.URL.Query().Get("%s")`, tagValue))
	}
	if len(attributions) == 0 {
		return func() error { return nil }
	}
	return g.w.wf(`
if err:=tools.GroupError("query",
%s,
); err!=nil { return err }`, strings.Join(attributions, ",\n"))
	return g.w.wf("// query\n\n%s\n%s", strings.Join(attributions, "\n"), sourceRowDelimiter)

}

func (g *Generator[T, R]) writeValidation() func() error {
	if !g.hasValidations {
		return func() error { return nil }
	}
	if reflect.TypeFor[T]().Implements(reflect.TypeFor[parsers.Validator]()) {
		return g.w.wf(`// Validation (native)
if err:=h.Validate();err!=nil{ return err}`)
	}
	if reflect.TypeFor[T]().Implements(reflect.TypeFor[parsers.ValidatorGetter]()) {
		return g.w.wf(`// Validation with custom validator
validate := h.GetValidator()
if err:=validate.Struct(h);err!=nil{return err}`)
	}

	return g.w.wf(`// Validation with default validator
validate := validator.New(validator.WithRequiredStructEnabled())
if err:=validate.Struct(h);err!=nil{return err}`)
}

func (g *Generator[T, R]) findSourceFile(t reflect.Type) (string, error) {
	// find source folder for package
	sourceFolder, found := strings.CutPrefix(t.PkgPath(), g.moduleName)
	if !found {
		return "", fmt.Errorf("type %s from package %s is not from the current module %s", t.Name(), t.PkgPath(), g.moduleName)
	}
	sourceFolder = path.Join(g.projectRoot, sourceFolder)

	if stat, err := os.Stat(sourceFolder); err == nil && stat.IsDir() {
		return findSourceFileForType(sourceFolder, t.Name())
	}
	return "", fmt.Errorf("couldn't find source file for type %s", t.Name())

}

func (g *Generator[T, R]) GetWriter() (fw io.WriteCloser, err error) {
	w, err := os.Create(g.outputs[g.tReq.Name()])
	if err != nil {
		return nil, err
	}
	return NewFormatWriter(w), nil
}
