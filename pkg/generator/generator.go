package generator

// https://github.com/mailru/easyjson
import (
	"fmt"
	"io"
	"os"
	"reflect"
	"strings"

	"github.com/guionardo/go-router/pkg/attributor"
	"github.com/guionardo/go-router/pkg/generator/parsers"
	"github.com/guionardo/go-router/pkg/outputs"
	reflections "github.com/guionardo/go-router/pkg/reflect"
	"github.com/guionardo/go-router/pkg/tools"
	"github.com/guionardo/go-router/router"
	"github.com/guionardo/go/pkg/set"
	"github.com/mailru/easyjson"
)

type (
	mu interface {
		easyjson.MarshalerUnmarshaler
	}
	Generator[T mu, R mu] struct {
		tReq, tRes     reflect.Type
		err            error
		w              *GoFileBuilder
		imports        set.Set[string] // alias:path
		moduleName     string
		projectRoot    string
		attr           attributor.Attributor
		hasValidations bool
		outputFiles    *outputs.Outputs[T, R]
		bodyParser     *parsers.Body[T]
	}
)

func New[T mu, R mu]() *Generator[T, R] {
	tType := reflections.New[T]()
	g := &Generator[T, R]{
		imports:     set.New[string](),
		attr:        attributor.New[T](),
		outputFiles: outputs.New[T, R](),
		projectRoot: tType.ProjectRootFolder,
		moduleName:  tType.ModuleName,
	}

	g.tReq = g.addType(reflect.TypeFor[T]())
	g.tRes = g.addType(reflect.TypeFor[R]())

	pathParser := parsers.NewPath[T]()
	queryParser := parsers.NewQuery[T]()
	headerParser := parsers.NewHeader[T]()
	g.bodyParser = parsers.NewBody[T]()
	validatorParser := parsers.NewValidators[T]()

	g.hasValidations = validatorParser.HasValidations

	g.imports.AddMultiple("net/http", tools.ToolsImport, router.RouterImport)
	g.imports.UpdateFrom(pathParser.Imports)
	g.imports.UpdateFrom(queryParser.Imports)
	g.imports.UpdateFrom(headerParser.Imports)
	g.imports.UpdateFrom(validatorParser.Imports)
	g.imports.UpdateFrom(g.bodyParser.Imports)

	return g
}

func (g *Generator[T, R]) addType(t reflect.Type) reflect.Type {
	tType := reflections.NewFromType[T](t)
	if tType.Error != nil {
		panic(tType.Error)
	}

	//TODO: Validar
	// reader, _ := NewDocReader(tType.SourceFile)
	// reader.Print()

	return tType.Type
}

func (g *Generator[T, R]) Generate() (err error) {
	// parser

	if err = g.generateParser(); err != nil {
		return err
	}

	// ProcessFile

	if err = g.generateProcess(); err == nil {
		outputs.SignFile(g.outputFiles.ProcessFile)
	}

	return err

}

func (g *Generator[T, R]) generateParser() error {
	w, err := g.GetWriter(g.outputFiles.ParseRequestFile)
	if err != nil {
		return err
	}

	defer w.Close()
	g.w = NewGoFileBuilder(w)

	g.w.write(
		g.w.wf("// Code generated by go-router for HTTP request parsing. DO NOT EDIT."),
		g.w.wf("// Request  Type: %s", g.tReq.String()),
		g.w.wf("// Generated File: %s", g.outputFiles.ParseRequestFile),
		g.w.wf("// Response Type: %s\n", g.tRes.String()),
		g.w.wf("package %s", g.outputFiles.PackageName),

		g.writeImports,
		g.writeParser,
		g.writeParserBodyFunc,
		g.writeHandler,
		g.writeInit,
	)

	return g.err
}

func (g *Generator[T, R]) generateProcess() (err error) {
	if len(g.outputFiles.ProcessFile) == 0 {
		return nil
	}

	processMethod := fmt.Sprintf("func (h *%s) Process(r *http.Request) (%s, error) {", g.tReq.Name(), g.tRes.Name())
	tType := reflections.New[T]()
	if fileWithProcessMethod := tType.FindContentOnFiles(processMethod); len(fileWithProcessMethod) > 0 {
		//Process method just implemented
		return nil
	}
	w, err := g.GetWriter(g.outputFiles.ProcessFile)
	if err != nil {
		return err
	}

	defer w.Close()
	g.w = NewGoFileBuilder(w)
	g.w.write(
		g.w.wf("// Code generated by go-router for HTTP request parsing. ADD YOUR BUSINESS RULE HERE."),
		g.w.wf("// Request  Type: %s", g.tReq.String()),
		g.w.wf("// Generated File: %s", g.outputFiles.ProcessFile),
		g.w.wf("// Response Type: %s\n", g.tRes.String()),
		g.w.wf("package %s", g.outputFiles.PackageName),
		g.w.wf("import \"net/http\""),
		g.writeProcess,
	)
	return nil
}

func (g *Generator[T, R]) writeImports() error {
	g.w.ws("import (")
	for pkg := range g.imports.Iter() {
		g.w.ws(`"%s"`, pkg)
	}
	g.w.ws(")\n")
	return nil
}

func (g *Generator[T, R]) writeInit() error {
	g.w.write(
		g.w.wf(`
		// Hash validation for type
		func init() {
tools.ValidateHash[%s](0x%x)
	}`, g.tReq.Name(), tools.TypeHash(g.tReq)))
	return nil
}
func (g *Generator[T, R]) writeParser() error {
	g.w.write(
		g.w.wf("func (h *%s) ParseRequest(r *http.Request) error {", g.tReq.Name()),
		g.writeParserForBody(),
		g.writeParserForPath(),
		g.writeParserForHeaders(),
		g.writeParseQuery(),
		g.writeValidation(),
		g.w.wf("return nil"),
		g.w.wf("}"),
	)

	return nil
}

func (g *Generator[T, R]) writeProcess() error {
	//// func (h *RequestStruct) Process(r *http.Request) (ResponseStruct, error) {
	// 	return ResponseStruct{}, nil
	// }
	g.w.write(
		g.w.wf("func (h *%s) Process(r *http.Request) (%s, error) {", g.tReq.Name(), g.tRes.Name()),
		g.w.wf("// TODO: Add your business rule here"),
		g.w.wf("return %s{},nil", g.tRes.Name()),
		g.w.wf("}"),
	)
	return nil
}

func (g *Generator[T, R]) writeHandler() error {
	// func (h *RequestStruct) Handle(w http.ResponseWriter, r *http.Request) {
	// response, err := h.Process(r)
	// router.Handle(w, response, err)
	g.w.write(g.w.wf(`func (h *%s) Handle(w http.ResponseWriter, r *http.Request) {
	var (
		response any
		err      error
	)
	if err = h.ParseRequest(r); err == nil {
		response, err = h.Process(r)
	}
	router.Handle(w, response, err)
}`, g.tReq.Name()),
	)
	return nil
}

func (g *Generator[T, R]) writeParserBodyFunc() error {
	if bodyFunc := g.bodyParser.ParseBodyFunc(); len(bodyFunc) > 0 {
		g.w.write(g.w.wf(bodyFunc))

	}
	return nil
}

func (g *Generator[T, R]) writeParserForBody() func() error {
	if len(g.bodyParser.ParseBodyFunc()) > 0 {
		return g.w.wf(`if err:=h.ParseBody(r); err!=nil {return err}`)
	}
	return func() error { return nil }
}
func (g *Generator[T, R]) writeParserForPath() func() error {

	attributions := make([]string, 0)
	for field, tagValue := range getFieldsByTag(g.tReq, "path") {
		attributions = append(attributions, g.attr.Create(field, "h", `r.PathValue("%s")`, tagValue))
	}
	if len(attributions) == 0 {
		return func() error { return nil }
	}
	return g.w.wf(`
if err:=tools.GroupError("path",
%s,
); err!=nil { return err }`, strings.Join(attributions, ",\n"))
}

func (g *Generator[T, R]) writeParserForHeaders() func() error {
	attributions := make([]string, 0)
	for field, tagValue := range getFieldsByTag(g.tReq, "header") {
		attributions = append(attributions, g.attr.Create(field, "h", `r.Header.Get("%s")`, tagValue))
	}
	if len(attributions) == 0 {
		return func() error { return nil }
	}
	return g.w.wf(`
if err:=tools.GroupError("headers",
%s,
); err!=nil { return err }`, strings.Join(attributions, ",\n"))
}

func (g *Generator[T, R]) writeParseQuery() func() error {
	attributions := make([]string, 0)
	for field, tagValue := range getFieldsByTag(g.tReq, "query") {
		attributions = append(attributions, g.attr.Create(field, "h", `r.URL.Query().Get("%s")`, tagValue))
	}
	if len(attributions) == 0 {
		return func() error { return nil }
	}
	return g.w.wf(`
if err:=tools.GroupError("query",
%s,
); err!=nil { return err }`, strings.Join(attributions, ",\n"))

}

func (g *Generator[T, R]) writeValidation() func() error {
	if !g.hasValidations {
		return func() error { return nil }
	}
	if reflect.TypeFor[T]().Implements(reflect.TypeFor[parsers.Validator]()) {
		return g.w.wf(`// Validation (native)
if err:=h.Validate();err!=nil{ return err}`)
	}
	if reflect.TypeFor[T]().Implements(reflect.TypeFor[parsers.ValidatorGetter]()) {
		return g.w.wf(`// Validation with custom validator
validate := h.GetValidator()
if err:=validate.Struct(h);err!=nil{return err}`)
	}

	return g.w.wf(`// Validation with default validator
validate := validator.New(validator.WithRequiredStructEnabled())
if err:=validate.Struct(h);err!=nil{return err}`)
}

// GetWriter returns a NewFormatWriter for the fileName
func (g *Generator[T, R]) GetWriter(fileName string) (fw io.WriteCloser, err error) {
	w, err := os.Create(fileName)
	if err != nil {
		return nil, err
	}
	return NewFormatWriter(w, fileName), nil
}
